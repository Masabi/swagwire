{{>licenseInfo}}
package {{package}};

import {{modelPackage}}.*;
import {{invokerPackage}}.*;

{{#imports}}import {{import}};
{{/imports}}


{{^fullJavaUtil}}
    import java.util.ArrayList;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;
{{/fullJavaUtil}}

import com.github.tomakehurst.wiremock.client.MappingBuilder;
import com.github.tomakehurst.wiremock.client.WireMock;

{{>generatedAnnotation}}
{{#operations}}
    public class {{classname}} {
//    private ApiClient {{localVariablePrefix}}apiClient;

    public {{classname}}() {
//    this(Configuration.getDefaultApiClient());
//    this(Configuration.getDefaultApiClient());
    }

//    public {{classname}}(ApiClient apiClient) {
//    this.{{localVariablePrefix}}apiClient = apiClient;
//    }

    {{#operation}}
        /**
        * {{summary}}
        * {{notes}}
        {{#allParams}}
            * @param {{paramName}} {{description}}{{#required}} (required){{/required}}{{^required}} (optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
        {{/allParams}}
        {{#returnType}}
            * @return {{returnType}}
        {{/returnType}}
        * @throws ApiException if fails to make API call
        {{#isDeprecated}}
            * @Deprecated
        {{/isDeprecated}}
        {{#externalDocs}}
            * {{description}}
            * @see <a href="{{url}}">{{summary}} Documentation</a>
        {{/externalDocs}}
        */
        public {{#returnType}}RemoteOperation<{{{returnType}}}> {{/returnType}}{{^returnType}}void {{/returnType}}{{operationId}}({{#allParams}}{{{dataType}}} {{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) {
        Object {{localVariablePrefix}}localVarPostBody = {{#bodyParam}}{{paramName}}{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}};
        {{#allParams}}{{#required}}
            // verify the required parameter '{{paramName}}' is set
            if ({{paramName}} == null) {
            throw new IllegalArgumentException("Missing the required parameter '{{paramName}}' when calling {{operationId}}");
            }
        {{/required}}{{/allParams}}
        // create path and map variables


        String {{localVariablePrefix}}localVarPath = "{{{path}}}"{{#pathParams}}
            .replaceAll("\\{" + "{{baseName}}" + "\\}", {{localVariablePrefix}}escapeString({{{paramName}}}.toString())){{/pathParams}};

        final String[] {{localVariablePrefix}}localVarAccepts = {
            {{#produces}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/produces}}
        };
/*
        final String {{localVariablePrefix}}localVarAccept = {{localVariablePrefix}}selectHeaderAccept({{localVariablePrefix}}localVarAccepts);

        // query params
        {{javaUtilPrefix}}List<Pair> {{localVariablePrefix}}localVarQueryParams = new {{javaUtilPrefix}}ArrayList<Pair>();
        {{javaUtilPrefix}}List<Pair> {{localVariablePrefix}}localVarCollectionQueryParams = new {{javaUtilPrefix}}ArrayList<Pair>();
        {{javaUtilPrefix}}Map<String, String> {{localVariablePrefix}}localVarHeaderParams = new {{javaUtilPrefix}}HashMap<String, String>();
        {{javaUtilPrefix}}Map<String, Object> {{localVariablePrefix}}localVarFormParams = new {{javaUtilPrefix}}HashMap<String, Object>();

        {{#queryParams}}
            {{localVariablePrefix}}{{#collectionFormat}}localVarCollectionQueryParams.addAll({{localVariablePrefix}}apiClient.parameterToPairs("{{{collectionFormat}}}", {{/collectionFormat}}{{^collectionFormat}}localVarQueryParams.addAll({{localVariablePrefix}}apiClient.parameterToPair({{/collectionFormat}}"{{baseName}}", {{paramName}}));
        {{/queryParams}}

        {{#headerParams}}if ({{paramName}} != null)
        {{localVariablePrefix}}localVarHeaderParams.put("{{baseName}}", {{localVariablePrefix}}apiClient.parameterToString({{paramName}}));
        {{/headerParams}}

        {{#formParams}}if ({{paramName}} != null)
        {{localVariablePrefix}}localVarFormParams.put("{{baseName}}", {{paramName}});
        {{/formParams}}


            final String[] {{localVariablePrefix}}localVarContentTypes = {
        {{#consumes}}"{{{mediaType}}}"{{#hasMore}}, {{/hasMore}}{{/consumes}}
            };
            final String {{localVariablePrefix}}localVarContentType = {{localVariablePrefix}}apiClient.selectHeaderContentType({{localVariablePrefix}}localVarContentTypes);

            String[] {{localVariablePrefix}}localVarAuthNames = new String[] { {{#authMethods}}"{{name}}"{{#hasMore}}, {{/hasMore}}{{/authMethods}} };

        {{#returnType}}
                GenericType<{{{returnType}}}> {{localVariablePrefix}}localVarReturnType = new GenericType<{{{returnType}}}>() {};
                return {{localVariablePrefix}}apiClient.invokeAPI({{localVariablePrefix}}localVarPath, "{{httpMethod}}", {{localVariablePrefix}}localVarQueryParams, {{localVariablePrefix}}localVarCollectionQueryParams, {{localVariablePrefix}}localVarPostBody, {{localVariablePrefix}}localVarHeaderParams, {{localVariablePrefix}}localVarFormParams, {{localVariablePrefix}}localVarAccept, {{localVariablePrefix}}localVarContentType, {{localVariablePrefix}}localVarAuthNames, {{localVariablePrefix}}localVarReturnType);
        {{/returnType}}{{^returnType}}
            {{localVariablePrefix}}apiClient.invokeAPI({{localVariablePrefix}}localVarPath, "{{httpMethod}}", {{localVariablePrefix}}localVarQueryParams, {{localVariablePrefix}}localVarCollectionQueryParams, {{localVariablePrefix}}localVarPostBody, {{localVariablePrefix}}localVarHeaderParams, {{localVariablePrefix}}localVarFormParams, {{localVariablePrefix}}localVarAccept, {{localVariablePrefix}}localVarContentType, {{localVariablePrefix}}localVarAuthNames, null);
        {{/returnType}}*/
                    {{#returnType}}

        // TODO this only works for Json right now - to do something else we need
        // to handle the serialization further down

        // These are inverted from the normal generation meaning as when programming
        // wiremock we're doing the inverse
        final String contentType = selectHeaderAccept(localVarAccepts);

            /**
             * This is probably going to be different depending on the operation being done -
             * maybe use the HTTP verb to figure it out
             */
            MappingBuilder mappingBuilder = WireMock.get(WireMock.urlEqualTo(localVarPath));
            return new WireMockedRemoteOperation<>(mappingBuilder, contentType);
        {{/returnType}}

            }
    {{/operation}}

       /**
         * TODO should be shared somewhere and can be static
         */
        public static String escapeString(String str) {
            try {
                return java.net.URLEncoder.encode(str, "utf8").replaceAll("\\+", "%20");
            } catch (java.io.UnsupportedEncodingException e) {
                return str;
            }
        }

        public static String selectHeaderAccept(String[] accepts) {
            if (accepts.length == 0) {
                return null;
            }
            for (String accept : accepts) {
                if (isJsonMime(accept)) {
                    return accept;
                }
            }
            return join(accepts, ",");
        }

        public static boolean isJsonMime(String mime) {
            String jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$";
            return mime != null && (mime.matches(jsonMime) || mime.equalsIgnoreCase("application/json-patch+json"));
        }

          public static String join(String[] array, String separator) {
            int len = array.length;
            if (len == 0) return "";

            StringBuilder out = new StringBuilder();
            out.append(array[0]);
            for (int i = 1; i < len; i++) {
              out.append(separator).append(array[i]);
            }
            return out.toString();
          }


{{/operations}}
}